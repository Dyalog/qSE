:NameSpace Utils ⍝ V1.53
⍝ Namespace containing :Includable utility functions
⍝ 2015 11 12 Adam: Auto version + format & layout now handle matrices
⍝ 2016 05 29 DanB: added setupKeys and double quotes for JS
⍝ 2017 05 16 JohnS: Added ]box -t=def functionality
⍝ 2017 05 23 Adam: Added 16.0's new primitives
⍝ 2017 06 12 Adam: Handle when boxing hasn't been initialised
⍝ 2018 02 11 JohnS: Moved functions defs, exports and in to this file.
⍝ 2018 03 13 Adam: repObj recog sysconsts and optional ⍺ for parens if needed, ⊣, ⊢, Unicode chars
⍝ 2018 03 21 JMS: [15591] improvements to ]defs
⍝ 2018 04 18 Adam: ]??cmd → ]cmd -??
⍝ 2018 11 06 Adam: repObj handle complex arithmetic progressions
⍝ 2018 01 17 Adam: [16805] fall back to serialisation if hitting limit
⍝ 2020 05 21 Adam: refactor, [18076] Add Config
⍝ 2020 05 22 Adam: Cleanup
⍝ 2020 05 26 Adam: [18126] display LF as CR
⍝ 2020 05 27 Adam: Add Hoof (○¨)
⍝ 2020 09 14 Adam: repObj: Full precision DECFs, proper error on ref
⍝ 2020 10 16 Adam: Moved CD from ]CD and added relativeTies
⍝ 2021 01 11 Adam: Prevent layoutPar from hanging
⍝ 2021 01 19 Adam: repObj with guaranteed precision and QA
⍝ 2021 03 24 Adam: Add APLcart API
⍝ 2021 04 01 Adam: Let APLcart cache expire after 1 day
⍝ 2021 04 15 Adam: Handle non-string config values in registry
⍝ 2021 05 09 Adam: Include "]" in bracket axis
⍝ 2021 06 07 Adam: Add ⎕SE.Dyalog.Utils.ExpandConfig (from ]Get's ExpEnv)
⍝ 2021 07 15 Adam: Use disp and display from dfns.dws but amend for CRLF
⍝ 2021 08 02 Adam: Restore old display that can handle clunky chars
⍝ 2021 08 12 Adam: Add View to view in a read-only Editor window
⍝ 2021 10 20 Adam: ExpandConfig support for ${env:name}
⍝ 2021 11 03 Adam: Handle locked functions
⍝ 2021 11 04 Adam: ExpandConfig support for escapes and choosing syntax
⍝ 2022 07 04 Adam: Make APLcart remove URLs before searching
⍝ 2022 12 07 Adam: ExpandConfig include POSIX extensions (like ~) on POSIX-like OS, and handle errors
⍝ 2023 03 06 Adam: Make APLcart fall back to local table if no internet
⍝ 2023 05 16 Adam: [19376] specify dll if .NET "Core"
⍝ 2023 05 25 Adam: Fix typo in nkds
⍝ 2023 05 30 Adam: Staticise ⎕USING as the Core value works in Framework

    :Section General
    ⎕IO←⎕ML←1

    ∇ r←Version
      r←⊢/∊'V'⎕VFI⊃⎕SRC ⎕THIS
    ∇

    where←{⍵/⍳⍴⍵}        ⍝ Indices of 1's in ⎕IO 1

    ∇ r←{origin}Config param;os;ver;NamesValues;EnvVars;env;claValues;Names;cla;cfg;all;OnlySet;val;loc;Adjust;ErrIf;cmd;⎕USING;sk;hk;key;name
    ⍝ Values of configuration parameters (optionally with origin)
    ⍝
    ⍝ params  name or names; '' or ⍬ to return all
    ⍝
    ⍝ origin  =0: don't show origin of value (default)
    ⍝         =1: show short origin of value
    ⍝         =2: show long origin of value
    ⍝
    ⍝ r       origin=0 and params is simple:  simple                   value
    ⍝         origin>0 and params is simple:  vector with      (source value)
    ⍝         origin=0 and params is nested:  matrix of   (name        value) rows
    ⍝         origin>0 and params is nested:  matrix of   (name source value) rows
    ⍝         origin=0 and params is '' or ⍬: matrix of   (name        value) rows
    ⍝         origin>1 and params is '' or ⍬: matrix of   (name source value) rows
     
      :If 900⌶⍬ ⋄ origin←0 ⋄ :EndIf ⍝ default left
      (os ver)←2↑# ⎕WG'APLVersion'
     
      ErrIf←⎕SIGNAL{(⌈/⍵)⍴⊂('EN' 11)('Message'⍺)}
      'requires 18.0 or higher'ErrIf 18>2 1⊃'.'⎕VFI ver
      'right argument (parameters) must be ⍬ character vector(s) or ⍬ (all)'ErrIf(3∘≤∘|∘≡,''⍬∘∊)param
      'left argument (show origin) must be 0 (none), 1 (short), or 2 (long)'ErrIf~0 1 2∊⍨⊂origin
     
      :If ⍬''∊⍨⊂param ⍝ all
          :Trap 0
              env←⎕SH cmd←'env' 'set'⊃⍨1+'Windows'≡7↑os
          :Else
              ⎕SIGNAL⊂⎕DMX.(('EN'EN)'Message'(Message,' (attempting to run ⎕SH ''',cmd,''')'))
          :EndTrap
          cfg←⊣/161⌶0 ⍝ unofficial: config file contents
          cla←2 ⎕NQ'.' 'GetCommandLineArgs'
     
          OnlySet←{⍵/⍨'='∊¨⍵↑¨⍨⌊/⍵∘.⍳'''"'} ⍝ only name=value args
          Names←{⍵↑⍨¯1+⍵⍳'='}¨              ⍝ names up until "="
          all←{⍵[⍋⍵]}∪1 ⎕C cfg,Names env,OnlySet cla
     
          r←{⍵⌿⍨×≢¨⊢/⍵}origin Config all ⍝ filter out empty vars
      :ElseIf 1≥|≡param ⍝ one
          (val loc)←160⌶param ⍝ unofficial: value and origin of configuration parameter
     
          Adjust←{ ⍝ Expand or abbreviate origin
              (short long)←⍺=⍳2
              short∧'Environment variable'≡⍵:'Env var'
              short∧'Built-in default'≡⍵:'Default'
              short∧'Not defined'≡⍵:'None'
              long∧'Registry'≡⍵:⊃4070⌶0 ⍝ unofficial: registry key
              short:∊1↓⎕NPARTS ⍵ ⍝ strip paths from filenames
              ⍵
          }
          :If loc≡'Registry'
              ⎕USING←'Microsoft.Win32,Microsoft.Win32.Registry'
              hk←Registry⍎'_(\w)'⎕R'\u1'⊃'^HKEY(_\w+)'⎕S'\l1'⊃4070⌶0
              (key name)←param⊂⍨⍸⍣¯1⊢1,⌈/⍸'\'='\',param
              sk←hk.OpenSubKey⊂'\'(⍳⍨↓,⍨,key⍨)⊃4070⌶0
              val←sk.GetValue,/1↓⎕NPARTS param
          :EndIf
          r←val{⍺ ⍵}⍣(origin∊1 2)⍨origin Adjust loc ⍝ append origin if asked for
      :ElseIf 0=≢param
          r←0(2+×origin)⍴⊂'' ⍝ 2 or 3 columns for without and with origin
      :Else ⍝ multiple
          r←↑origin(⊢{(⊆⍺),⊆⍵}Config)¨param ⍝ prepend name column
      :EndIf
    ∇

      ExpandConfig←{ ⍝ Expand Configuration settings (includes environment variables and cmdline params) in text ⍵
          ⍝ ExpandConfig 'your ws size is [MAXWS]' → 'your ws size is 2G'
          ⍝ ExpandConfig 'your ws size is $MAXWS' → 'your ws size is 2G'
          ⍝ ExpandConfig 'your ws size is %MAXWS%' → 'your ws size is 2G'
          ⍝ ExpandConfig 'your ws size is $env:MAXWS' → 'your ws size is 2G'
          ⍝ ExpandConfig 'your ws size is ${env:MAXWS}' → 'your ws size is 2G'
          ⍝ ExpandConfig 'your ws size is ${MAXWS}' → 'your ws size is 2G'
          ⍝ Handles ~ and ~+ and ~- under UX only
          ⍝ Use \ or ^ or ` to escape patterns
          ⍝ optionally restrict pattern type and escape using left argument as per below
     
          ⍝ For user's home dir, use ⎕SE.SALTUtils.USERDIR
          0::⎕SIGNAL⊂⎕DMX.(('EN'EN)('Message'Message))
     
          ⍺←0
          type←⎕C⊂⍺
          ps←type∊'ps' 'powershell' 'psh'
          cmd←type∊'cmd' 'dos' 'win' 'windows' 'batch' 'command.com' 'cmd.exe'
          salt←type∊'salt' 'dyalog'
          posix←type∊'posix' 'linux' 'unix' 'ux' 'pi' 'aix' 'mac' 'macos' 'qshell' 'rc'
          posix∨←'sh'≡¯2↑⊃type
     
          Esc←'[%\\&]'⎕R'\\&'
          Untilde←{
              ⎕SE.SALTUtils.WIN>posix:⍵
              specials←Esc Config¨'PWD' 'OLDPWD' 'HOME'
              subs←'\1'∘,¨specials,¨⊂'\2'
              '(\W|^)~\+()' '(\W|^)~-()' '(\W|^)~(\W|$)'⎕R subs⍠'UCP' 1⊢⍵
          }
          Sub←{⍵⍵ ⎕R(⍺⍺{⍵.PatternNum:⍺⍺(Config ¯1↓↓)⍵.Match ⋄ ⊢/⍵.Match})⊢⍵} ⍝ chop leading ⍺ chars
     
          ps:6 Sub'`[$`]' '\$\{env:([^}]+)}'⊢'\$env:([\pL_]\w*)'⎕R'${env:\1}'⊢⍵
          cmd:1 Sub'\^[%^]' '%([^%]+)%'⊢⍵
          salt:1 Sub']' '\[([^]]+)]'⊢⍵
          posix:2 Sub'\\[$\\]' '\$\{([^}]+)}'⊢'\$([\pL_]\w*)'⎕R'${\1}'⍠'UCP' 1 Untilde ⍵
          0≢⍺:⎕SIGNAL⊂('EN' 11)('Message' 'Left argument must be environment type (ps/cmd/salt/ux/etc.)')
     
          bracked←'\$env:([\pL_]\w*)' '\$\{env:([^}]+)}' '\$([\pL_]\w*)' '\$\{([^}]+)}' '\[([^]]+)]' '%([^%]+)%'⎕R'[\1]'⍠'UCP' 1 Untilde ⍵
          1 Sub'\\[$\\]|\^[%^]|`[$`]' '\[([^]]+)]'⊢bracked
      }

    ∇ names←relativeTies;rel ⍝ Report which files are tied with relative names
      names←{(+/∨\' '≠⌽⍵)↑¨↓⍵}↑⊃,/↓¨⎕NNAMES ⎕FNAMES
      :If 'Win'≡3↑⊃# ⎕WG'APLVersion'
          rel←~≢¨'^([\\/]|\w:)[\\/]'⎕S 3¨names ⍝ doesn't begin with // or L:/
      :Else
          rel←'/'≠⊃¨names
      :EndIf
      names←↑rel/names
    ∇

      CD←{ ⍝ Current (empty ⍵: non-shy result is current dir) or Change (non-empty ⍵: shy result is old dir) Directory
      ⍝ WARNING: Changing directory under program control runs the risk of interfering with relative paths.
      ⍝ Checks (if monadic or ⍺=0) for relative ⎕NTIEd/⎕FTIEd/⎕FSTIEd files only, but not for ⎕NA ⎕XT ⎕SH/⎕CMD etc.
      ⍝ Skips check if ⍺=1
      ⍝ Provided as-is ─ use at your own risk!
          ⍺←0
          0::⎕SIGNAL⊂⎕DMX.(('EN'EN)('EM'EM)('Message'Message))
          ~0∊⍴⍵:_←⍺ CDshy ⍵ ⍝ change: shy
          ⍺ CDshy ⍵         ⍝ report: not shy
      }

    ∇ {old}←force CDshy new;OS;is64;t;get;lib;chdir;⎕ML ⍝ Current/Change Directory
    ⍝ empty "new": only report; non-empty "new": change dir
    ⍝ warns about tied files with relative tie names if force=0, skips check if force=1
      ⎕ML←1
      OS←3↑⊃# ⎕WG'APLVersion'
      :If 'Win'≡OS                 ⍝ Under Windows we do the association here because we need
          t←'A*'[1+80=⎕DR'']       ⍝ the programs to GET the current directory
          'get'⎕NA'U Kernel32|GetCurrentDirectory',t,' U >0T' ⍝ Associate Get function
          old←2⊃get 260 260                                   ⍝ in all cases we return the current dir
          'chdir'⎕NA'U Kernel32|SetCurrentDirectory',t,' <0T' ⍝ Associate Set function
      :Else
          old←⊃⎕SH'pwd'
      :EndIf
     
      :If ~0∊⍴new         ⍝ change directory
          :If ~force
              ⎕SIGNAL(×≢relativeTies)/⊂('EN' 24)('Message'('Some files (',('.relativeTies',⍨⍕⎕THIS),') ⎕NTIEd/⎕FTIEd with relative names (use left argument 1 to ignore)'))
          :EndIf
     
          :If 'Win'≡OS
             ⍝ chdir returns a single int: 1=ok
              ('Unable to change directory: ',new,': Invalid directory')⎕SIGNAL(chdir⊂new)↓22
          :Else
              :Select OS
              :Case 'AIX'
                  is64←32={z←⍵ ⋄ ⎕SIZE'z'}⍬
                  lib←'I libc.a(shr',(is64/'_64'),'.o)|chdir <0T1[]'
              :Case 'Lin'
             ⍝ Extract real name of libc that we are actually using
                  t←⊃⎕SH'echo $PPID'
                  t←⎕SH'ldd /proc/',t,'/exe'
                  lib←⊃('^\s*libc\.so\b.*=>\s*(\S*)'⎕S'\1')t
                  lib←'I ',lib,'|chdir <0T1[]'
              :Case 'Mac'
                  lib←'I /usr/lib/libc.dylib|chdir <0T1[]'
                  ⍝ chdir returns a single integer: 0=ok
              :EndSelect
              ⎕NA lib
              ('Unable to change directory: ',new,': Invalid directory')⎕SIGNAL(0≠chdir⊂new)/22
          :EndIf
      :EndIf
    ∇

    APLcartTableCache←⍬
    APLcartTableTime←0
    ∇ {t}←APLcartTable force;hc;data;resp;url;empty;old;tsv
      empty←0=≢APLcartTableCache
      old←APLcartTableTime<¯1+1 ⎕DT'Z'
      :If force∨empty∨old
          url←'https://raw.githubusercontent.com/abrudz/aplcart/master/table.tsv'
          hc←⎕SE.SALT.Load'HttpCommand -nolink'
          resp←hc.Get url
          :If 0≠resp.rc
          :OrIf 0=≢resp.Data ⍝ fall back to local file; try internet again next time
              tsv←⊃⎕NGET'/spice/table.tsv',⍨⎕SE.SALTUtils.getEnvir'SALT'
          :Else
              tsv←resp.Data
              APLcartTableCache←tsv
              APLcartTableTime←1 ⎕DT'Z'
          :EndIf
          t←tsv
      :Else
          t←APLcartTableCache
      :EndIf
      t←'.*\r?\n'⎕R''⍠'Mode' 'D'⍠'ML' 1⍠'ResultText' 'Nested'⊢t ⍝ remove header and URLs
    ∇
      APLcart←{
          ⍺←0 ⍝ all columns
          terms←⊆' '(≠⊆⊢)⍣(' '∊⍵),⍵
          Filter←{
              regex←'//'≡(⊃,⊃∘⌽)⍺
              pat←regex↓(-regex)↓⍺
              pat ⎕S'%'⍠'Regex'(regex 1)⍠'ML' 1⍠1⊢⍵
          }
          26::⎕SIGNAL⊂⎕DMX.(('EN'EN)('EM'EM)('Message'Message))
          noUrls←'(\t)(http\S+)?\t(http\S+)?$'⎕R'\1\1'⊢APLcartTable 0
          i←noUrls⍳⊃Filter/terms,⊂noUrls
          r←i⊃¨⊂APLcartTable 0
          2↑⍤1⍣(~⍺)⎕CSV⍠'Separator'(⎕UCS 9)⍠'QuoteChar' ''⍠'DoubleQuote' 0⊂r
      }

    :EndSection
    :Section Strings

    lc←'abcdefghijklmnopqrstuvwxyzàáâãåèéêëòóôõöøùúûäæüìíîïðçñ' ⍝ (lower case alphabet)
    uc←'ABCDEFGHIJKLMNOPQRSTUVWXYZÀÁÂÃÅÈÉÊËÒÓÔÕÖØÙÚÛÄÆÜÌÍÎÏÐÇÑ' ⍝ (upper case alphabet)
    fromto←{n←⍴1⊃(t f)←⍺ ⋄ ~∨/b←n≥i←f⍳s←,⍵:s ⋄ (b/s)←t[b/i] ⋄ (⍴⍵)⍴s} ⍝ from-to casing fn

    lcase←lc uc∘fromto ⍝ :Includable Lower-casification of simple array
    ucase←uc lc∘fromto ⍝ Ditto Upper-casification

    cut←{⍺←⍵∊1↑⍵ ⋄ ⎕ml←1 ⋄ 1↓¨⍺⊂⍵}                  ⍝ exclude delimiters cut

      dtb←{                                         ⍝ Drop Trailing Blanks.
          ⍺←' ' ⋄ 1<|≡⍵:(⊂⍺)∇¨⍵                     ⍝ nested?
          2<⍴⍴⍵:(¯1↓⍴⍵){(⍺,1↓⍴⍵)⍴⍵}⍺ ∇,[¯1↓⍳⍴⍴⍵]⍵   ⍝ array
          1≥⍴⍴⍵:(-+/∧\⌽⍵∊⍺)↓⍵                       ⍝ vector
          (~⌽∧\⌽∧⌿⍵∊⍺)/⍵                            ⍝ matrix
      }

      dmb←{                                         ⍝ Drop Multiple Blanks.
          ⍺←' ' ⋄ 1<|≡⍵:(⊂⍺)∇¨⍵                     ⍝ nested?
          2<⍴⍴⍵:(¯1↓⍴⍵){(⍺,1↓⍴⍵)⍴⍵}⍺ ∇,[¯1↓⍳⍴⍴⍵]⍵   ⍝ array
          2>⍴⍴⍵:(2∨/(~⍵∊⍺),1)/⍵                     ⍝ vector
          (2∨/(,∨⌿~⍵∊⍺),1)/⍵                        ⍝ matrix
      }

      drvSrc←{⎕ML←1                              ⍝ Linear representation of fnop named ⍵.
     
          src←⍺.⎕CR ⍵                             ⍝ source.
     
          qt←''''                                 ⍝ single quote
          qtd←{qt,((1+⍵=qt)/⍵),qt}                ⍝ quoted.
     
          sepr←{                                  ⍝ adjacent arrays.
              qt∨.≠(⊃⌽⍺),⊃⍵:⍺,⍵                   ⍝ adjacent quoted vectors
              ⍺,' ',⍵                             ⍝ blank-separated.
          }
     
          array←{
              0=≡⍵:scalar ⍵                       ⍝ simple scalar
              1 1≡(≡⍵),⍴⍴⍵:vector ⍵               ⍝ simple vector.
              1=≡⍵:1 p(∇⍴⍵),'⍴',∇,⍵               ⍝ high-rank simple.
              0=⍴⍴⍵:1 p'⊂',∇⊃⍵                    ⍝ scalar
              1=⍴⍴⍵:⊃sepr/⊃,/(~ischar¨⍵)p∘∇¨⍵     ⍝ nested vector
              1 repObj ⍵                          ⍝ FIXME
          }
     
          scalar←{                                ⍝ scalar value
              ischar ⍵:qtd ⍵                      ⍝ char
              ⍕,⍵                                 ⍝ number or ref
          }
     
          vector←{                                ⍝ simple vector.
              0=⍴⍵:⊃(ischar ⍵)⌽'⍬'(qtd'')         ⍝ null: '' or ⍬.
              1=⍴⍵:1 p scalar⊃⍵                   ⍝ single vector → (,0)
              ∧/isnum¨⍵:⍕⍵                        ⍝ simple numeric vec:
              ∧/ischar¨⍵:qtd ⍵                    ⍝ simple char char vec:
              1 repObj ⍵                          ⍝ FIXME
          }
     
          uni←80=⎕DR''                            ⍝ unicode version
     
          pf0←'+-×÷⌊⌈|*⍟<≤=≥>≠∨∧⍱⍲!?~○'           ⍝ scalar fns.
          pf1←'⌷/⌿\⍀∊⍴↑↓⍳⊂⊃∩∪⊣⊢⊥⊤,⍒⍋⍉⌽⊖⌹⍕⍎⍪≡≢⍷'   ⍝ other fns.
          pfu←⎕UCS uni/8838 9080                  ⍝ where, condencl
          pfns←pf0,pf1,pfu                        ⍝ primitive fns.
     
          kvr←⎕UCS uni/9000+16 18 56 60           ⍝ key, stencil, variant, rank
          pops←'/\⌿⍀.¨∘⍨&⍣[@⌶',kvr                ⍝ primitive ops.
     
          ispfn←{(⊂,⍵)∊,¨pfns}
          ispop←{(⊂,⍵)∊,¨pops}
          isnum←{0≡⊃0⍴⍵}
          ischar←{' '≡⊃0⍴⍵}
     
          isdfn←{             ⍝ probably the ⎕cr of a dfn
              1≠≡⍵:0          ⍝ too deep
              ~(⍴⍴⍵)∊2 1:0    ⍝ not a matrix (or vector)
              1≠⊃⍴↑,↓⍵:0      ⍝ not a 1-liner
              '}'≠⊃⌽⍵:0       ⍝ doesn't end in ...}
              '{'=⊃⍵:1        ⍝ starts with {...
              1∊'←{'⍷⍵        ⍝ starts with name←{
          }
     
          isderv←{            ⍝ probably the ⎕cr of a derived fn.
              ~1=⍴⍴⍵:0        ⍝ not a vector.
              ~(⍴⍵)∊2,⍺+2:0   ⍝ not monadic or dyadic operator.
              op←⊃⍺↓⍵         ⍝ (curried) operator.
              pop←(⊂op)∊pops  ⍝ primitive operator
              dop←isdfn op    ⍝ D-operator.
              pop∨dop         ⍝ operator.
          }
     
          istrain←{           ⍝ probably the ⎕cr of a fn train.
              ~1=⍴⍴⍵:0        ⍝ not a vector.
              ~(⍴⍵)∊2 3:0     ⍝ not 2- or 3-train
              ∧/isfn¨¯2↑⍵     ⍝ last two tines are fns
          }
     
          issysfn←{           ⍝ is a ⎕fn?
              1≠≡⍵:0          ⍝ too deep
              1≠⍴⍴⍵:0         ⍝ not a vector
              '⎕'≠⊃⍵:0        ⍝ doesn't start '⎕...'
              1               ⍝ ok.
          }
     
          isfn←{(isdfn ⍵)∨(ispfn ⍵)∨(istrain ⍵)∨(0∘isderv ⍵)∨(1∘isderv ⍵)∨issysfn ⍵}
     
          p←{⍺=0:⍵ ⋄ '(',⍵,')'}   ⍝ ⍺-conditional parens.
     
          def←{
              ispfn ⍵:⍵                                                ⍝ primitive fn.
              ispop ⍵:⍵                                                ⍝ primitive oper.
              isdfn ⍵:(∨\'{'=,⍵)/,⍵                                    ⍝ regular dfn: without 'name←'.
              pp←'def'≢'⎕SE.Dyalog.Out.B.trains'{2=⎕NC ⍺:⍎⍺ ⋄ ⍵}'box'  ⍝ fully parenthesised
              1 isderv ⍵:⍺ p↑,/((⍴⍵)↑pp 0 1)∇¨⍵                        ⍝ derived fn.
              0 isderv ⍵:⍺ p↑,/0 1 ∇¨⍵                                 ⍝ right-operand curry.
              pr←pp∨(1∘isderv<2=≢)⊃⌽⍵                                  ⍝ parens right: atop +(++) ←≢→ +++
              pl←~1 isderv⊃⍵                                           ⍝ parens left:
              msk←pl,(2↓1⊣¨⍵),pr                                       ⍝ parens
              istrain ⍵:⍺ p↑,/msk ∇¨⍵                                  ⍝ train
              issysfn ⍵:⍵                                              ⍝ system fn.
              array ⍵
          }
     
          ,↑0 def src
      }

      ∆FMT1←{
          ⎕FMT(⎕UCS 13)@{⍵=⎕UCS 10}⍵/⍤1⍨~⍵⍷⍨⎕UCS 13 10
      }

      disp←{⎕IO ⎕ML←0 1                           ⍝ Boxed sketch of nested array.
     
          ⍺←⍬ ⋄ opts←⍺,(⍴,⍺)↓1 1 1 0 ⎕PP          ⍝ option defaults:
          dec bch ctd sep ⎕PP←5↑opts              ⍝ decor, smooth, centred, separate pp.
     
          ul uc ur←bch⊃⌽'┌┬┐' '.'                 ⍝ upper──┐ ┌───left
          ml mc mr←bch⊃⌽'├┼┤' '|+|'               ⍝ middle─┼×┼─centre
          ll lc lr←bch⊃⌽'└┴┘' ''''                ⍝ lower──┘ └──right
          vt hz←bch⊃⌽'│─' '|-'                    ⍝ vertical and horizontal.
     
          box←{                                   ⍝ Recursive boxing of nested array.
              isor ⍵:⎕FMT⊂⍵                       ⍝ ⎕or: '∇name'.
              1=≡,⍵:dec open ∆FMT1 dec open ⍵     ⍝ simple array: format.
              mat←matr 1/dec open ⍵               ⍝ matrix of opened subarrays.
              r c←×⍴mat                           ⍝ non-null rows/cols.
              dec<0∊r c:c/r⌿∇ 1 open mat          ⍝ undecorated null: empty result.
              subs←aligned ∇¨mat                  ⍝ aligned boxed subarrays.
              (≢⍴⍵)gaps ⍵ plane subs              ⍝ collection into single plane.
          }
     
          aligned←{                               ⍝ Alignment and centring.
              rows cols←sepr⍴¨⍵                   ⍝ subarray dimensions.
              sizes←(⌈/rows)∘.,⌈⌿cols             ⍝ aligned subarray sizes.
              ctd=0:sizes↑¨⍵                      ⍝ top-left alignment.
              v h←sepr⌈0.5×↑(⍴¨⍵)-sizes           ⍝ vertical and horizontal rotation.
              v⊖¨h⌽¨sizes↑¨⍵                      ⍝ centred aligned subarrays.
          }
     
          gaps←{                                  ⍝ Gap-separated sub-planes.
              sep≤⍺≤2:⍵                           ⍝ not separating: done.
              subs←(⍺-1)∇¨⍵                       ⍝ sub-hyperplanes.
              width←⊃⌽⍴⊃subs                      ⍝ width of inter-plane gap.
              fill←(⍺ width-3 0)⍴' '              ⍝ inter-plane gap.
              ↑{⍺⍪fill⍪⍵}/1 open subs             ⍝ gap-separated planes.
          }
     
          plane←{                                 ⍝ Boxed rank-2 plane.
              sep∧2<⍴⍴⍺:⍺ join ⍵                  ⍝ gap-separated sub-planes.
              odec←(dec shape ⍺)outer ⍵           ⍝ outer type and shape decoration.
              idec←inner ⍺                        ⍝ inner type and shape decorations.
              (odec,idec)collect ⍵                ⍝ collected, formatted subarrays.
          }
     
          join←{                                  ⍝ Join of gap-separated sub-planes.
              sep←(≢⍵)÷1⌈≢⍺                       ⍝ sub plane separation.
              split←(0=sep|⍳≢⍵)⊂[0]⍵              ⍝ separation along first axis.
              (⊂⍤¯1⊢⍺)plane¨split                 ⍝ sub-plane join.
          }
     
          outer←{                                 ⍝ Outer decoration.
              sizes←1 0{⊃↓(⍉⍣⍺)⍵}¨sepr⍴¨⍵         ⍝ row and col sizes of subarrays.
              sides←sizes/¨¨vt hz                 ⍝ vert and horiz cell sides.
              bords←dec↓¨ml uc glue¨sides         ⍝ joined up outer borders.
              ↑,¨/(ul'')⍺ bords(ll ur)            ⍝ vertical and horizontal borders.
          }
     
          inner←{                                 ⍝ Inner subarray decorations.
              deco←{(type ⍵),1 shape ⍵}           ⍝ type and shape decorators.
              sepr deco¨matr dec open ⍵           ⍝ decorators: tt vv hh .
          }
     
          collect←{                               ⍝ Collected subarrays.
              lft top tt vv hh←⍺                  ⍝ array and subarray decorations.
              cells←vv right 1 open tt hh lower ⍵ ⍝ cells boxed right and below.
              boxes←(dec∨0∊⍴⍵)open cells          ⍝ opened to avoid ,/⍬ problem.
              lft,top⍪↑⍪⌿,/boxes                  ⍝ completed collection.
          }
     
          right←{                                 ⍝ Border right each subarray.
              types←2⊥¨(⍳⍴⍵)=⊂¯1+⍴⍵               ⍝ right border lower corner types.
              chars←mc mr lc lr[types]            ⍝    ..     ..      ..      chars.
              rgt←{⍵,(-≢⍵)↑(≢⍵)1 1/vt,⍺}          ⍝ form right border.
              ((matr 1 open ⍺),¨chars)rgt¨⍵       ⍝ cells bordered right.
          }
     
          lower←{                                 ⍝ Border below each subarray.
              bot←{⍵⍪(-1⊃⍴⍵)↑⍺ split ⍵}           ⍝ lower border.
              split←{((¯2+1⊃⍴⍵)/hz)glue ⍺}        ⍝ decorators split with horiz line.
              (matr↑,¨/⍺)bot¨matr ⍵               ⍝ cells bordered below.
          }
     
          type←{                                  ⍝ Type decoration char.
              dec<|≡⍵:hz                          ⍝ nested: '─'
              isor ⍵:'∇'                          ⍝ ⎕or:    '∇'
              sst←{                               ⍝ simple scalar type.
                  0=dec×⍴⍴⍵:hz                    ⍝ undecorated or scalar ⍕⍵: char,
                  (⊃⍵∊'¯',⎕D)⊃'#~'                ⍝ otherwise, number or space ref.
              }∘⍕                                 ⍝ ⍕ distinguishes type of scalar.
              0=≡⍵:sst ⍵                          ⍝ simple scalar: type.
              {(1=⍴⍵)⊃'+'⍵}∪,sst¨dec open ⍵       ⍝ array: mixed or uniform type.
          }
     
          shape←{                                 ⍝ Row and column shape decorators.
              dec≤0=⍴⍴⍵:⍺/¨vt hz                  ⍝ no decoration or scalar.
              cols←(×¯1↑⍴⍵)⊃'⊖→'                  ⍝ zero or more cols.
              rsig←(××/¯1↓⍴⍵)⊃'⌽↓'                ⍝ zero or more rows.
              rows←(¯1+3⌊⍴⍴⍵)⊃vt rsig'⍒'          ⍝ high rank decorator overrides.
              rows cols                           ⍝ shape decorators.
          }
     
          matr←{↑,↓⍵}                             ⍝ matrix from non-scalar array.
          sepr←{+/¨1⊂↑⍵}                          ⍝ vec-of-mats from mat-of-vecs.
          open←{16::(1⌈⍴⍵)⍴⊂'[ref]' ⋄ (⍺⌈⍴⍵)⍴⍵}   ⍝ stretched to expose nulls.
          isor←{1 ⍬≡(≡⍵)(⍴⍵)}                     ⍝ is ⎕or of object?
          glue←{0=⍴⍵:⍵ ⋄ ↑⍺{⍺,⍺⍺,⍵}/⍵}            ⍝ ⍵ interspersed with ⍺s.
     
          isor ⍵:⎕FMT⊂⍵                           ⍝ simple ⎕OR: done.
          1=≡,⍵:∆FMT1 ⍵                           ⍝ simple array: done.
          box ⍵                                   ⍝ recursive boxing of array.
      }

      display←{⎕IO ⎕ML←0                              ⍝ Boxed display of array.
          ⍺←⍬ ⋄ ch ⎕PP←2↑⍺,(⍴,⍺)↓1 ⎕PP                ⍝ default chars and precision
          chars←ch⊃'..''''|-' '┌┐└┘│─'                ⍝ ⍺: 0-clunky, 1-smooth.
     
          tl tr bl br vt hz←chars                     ⍝ Top left, top right, ...
     
          box←{                                       ⍝ Box with type and axes.
              vrt hrz←(¯1+⍴⍵)⍴¨vt hz                  ⍝ Vert. and horiz. lines.
              top←(hz,'⊖→')[¯1↑⍺],hrz                 ⍝ Upper border with axis.
              bot←(⊃⍺),hrz                            ⍝ Lower border with type.
              rgt←tr,vt,vrt,br                        ⍝ Right side with corners.
              lax←(vt,'⌽↓')[¯1↓1↓⍺],¨⊂vrt             ⍝ Left side(s) with axes,
              lft←⍉tl,(↑lax),bl                       ⍝ ... and corners.
              lft,(top⍪⍵⍪bot),rgt                     ⍝ Fully boxed array.
          }
     
          deco←{⍺←type open ⍵ ⋄ ⍺,axes ⍵}             ⍝ Type and axes vector.
          axes←{(-2⌈⍴⍴⍵)↑1+×⍴⍵}                       ⍝ Array axis types.
          open←{16::(1⌈⍴⍵)⍴⊂'[ref]' ⋄ (1⌈⍴⍵)⍴⍵}       ⍝ Expose null axes.
          trim←{(~1 1⍷∧⌿⍵=' ')/⍵}                     ⍝ Remove extra blank cols.
          type←{{(1=⍴⍵)⊃'+'⍵}∪,char¨⍵}                ⍝ Simple array type.
          char←{⍬≡⍴⍵:hz ⋄ (⊃⍵∊'¯',⎕D)⊃'#~'}∘⍕         ⍝ Simple scalar type.
          line←{(6≠10|⎕DR' '⍵)⊃' -'}                  ⍝ underline for atom.
     
          {                                           ⍝ Recursively box arrays:
              0=≡⍵:' '⍪(open ⎕FMT ⍵)⍪line ⍵           ⍝ Simple scalar.
              1 ⍬≡(≡⍵)(⍴⍵):'∇' 0 0 box ⎕FMT ⍵         ⍝ Object rep: ⎕OR.
              1=≡⍵:(deco ⍵)box open ∆FMT1 open ⍵      ⍝ Simple array.
              ('∊'deco ⍵)box trim ⎕FMT ∇¨open ⍵       ⍝ Nested array.
          }⍵
      }
      View←{ ⍝ in a read-only Editor window
          ⍺←⊃⎕RSI
          tmp←⍺.⎕NS ⍬
          tmp.output←⍵
          tmp.⎕ED⍠'ReadOnly' 1&'output'
      }
    :EndSection
    :Section Output
⍝ Support for ]defs and ]boxing:

      nabs←{                              ⍝ Name abstraction:
     
          subs←{                          ⍝ substitution of ⍵-names in ⍺-defns
              dfns←(⊃∘(⊃⌽)¨⍺)∊'{'         ⍝ mask of ⍺'s dfns
              vars←(⊃¨1↓¨⍺)∊2             ⍝ mask of ⍺'s vars
              srch←@{~dfns∨vars}          ⍝ search filter: ignoring vars and dfns
              deps←{|≡∘(⊃⌽)¨⍵}            ⍝ definition depths
              small←(deps ⍵)<⌈/deps ⍺     ⍝ small enough for substitution
              sort←{⍵[⍒|≡∘(⊃⌽)¨⍵]}        ⍝ in decreasing order of depth
              uniq←uvals(⊃⌽)¨⍵            ⍝ mask of unique ⍵-defns
              libs←sort(small∧uniq)/⍵     ⍝ small defns in decreasing order of depth
              foldl←{↑⍺⍺⍨/(⌽⍵),⊂⍺}        ⍝ fold left :: ⍺ ← ⍺ (⍺ ← ⍺ ∇ ⍵) ∇∇ [⍵]
              zipd←{↓⍉↑⍺⍺↓⍉↑⍵}            ⍝ under zipping: [N K D] ←→ [N][K][D]
              sub1 foldl∘libs zipd srch ⍺ ⍝ largest-to-smallest search of lib defns
          }                               ⍝ :: [N K D] ← [N K D] ∇ [N K D]
     
          sub1←{                          ⍝ defns ⍺ with name of library defn ⍵
              (Ns Ks Ds)(N K D)←⍺ ⍵       ⍝ accumulated defns, next library defn
              depth←|≡K                   ⍝ depth of kind-tree of sought item
              trav←⊃{                     ⍝ (kind-tree defn) traversal
                  ⍵≡D:(-kd ⍺)N            ⍝ match: -ive kind and name
                  depth≥|≡⍺:⍺ ⍵           ⍝ kind-tree shallow: done
                  ↓⍉↑⍺ ∇¨⍵                ⍝ subtrees search
              }/                          ⍝ :: K D ← ∇ K D
              srch←trav¨@{~Ns∊⊂N}         ⍝ search of all but self :: [K D] ← ∇ [K D]
              (⊂Ns),↓⍉↑srch↓⍉↑Ks Ds       ⍝ name replacement
          }                               ⍝ :: [N][K][D] ← [N][K][D] ∇ N K D
     
          uvals←{                         ⍝ mask of non-duplicated items
              grps←⊢∘⊂⌸⍵                  ⍝ value groups
              uniqs←∊(1=≢¨grps)/grps      ⍝ indices of unique values
              (⍳≢⍵)∊uniqs                 ⍝ non-duplicated items
          }                               ⍝ :: [?] ← ∇ [⍺]
     
          curried←{1 0≡(|⊃⌽⍵)∊4}          ⍝ is curried: lft(dop rgt)?
          join←{l(d r)←⍵ ⋄ l d r}         ⍝ rejoining:  lft(dop rgt) → lft dop rgt
          uncurry←curried currying join   ⍝ reversion to triples for derived fns
     
          kd←{0=≡⍵:⍵ ⋄ 3+4≡⊃⍵}            ⍝ kind from kind-tree
          nkd0←{1↓(⊂'' 0 ⍬),⍵}            ⍝ explicit prototypical item
          kinds←(⍺⍺>1 0 0 1)/2 3 4 9      ⍝ ⍺⍺: 0:none, 1:3 4, 2:2 3 4 9
          from←{(({kd⊃1↓⍵}¨⍵)∊⍺)/⍵}       ⍝ kind selection
          ⍺←⊃¨(3 4,(⍺⍺>1)/2 9)from ⍵      ⍝ default all names
          nkds←nkd0 ⍵[(⊃¨⍵)⍳(,¨⊆⍺)∩⊃¨⍵]   ⍝ subject NKDs
          uncurry¨nkds subs kinds from ⍵  ⍝ with names for values
     
    ⍝ :: [N K D] ← [N](A ∇∇)[N K D] ⍝ name-abstraction:
    ⍝ N := ⍞                        ⍝   Name: char vector
    ⍝ K := 2 | 3 | 4 | 9 | [K]      ⍝   Kind-tree: nested kinds
    ⍝ D := ' | [D]                  ⍝   Defn: nested ⎕CR vectors
    ⍝ A := 0 | 1 | 2                ⍝ abstract: 0:none 1:fns&ops 2:all
      }

      nkds←{                              ⍝ (Name Kind Defn)-tuples
     
          defs←{                          ⍝ defns from space ⍵
              Ns←~∘' '¨↓⍵.⎕NL 2 3 4 9     ⍝ all names
              Ks←⍵.(183⌶)¨Ns              ⍝ unofficial: all kind-trees
              ds←Ks prep∘⍵.⎕CR¨Ns         ⍝ all defns of fns and ops
              v←1↓⍵.⍎¨'0',(Ks∊2 9)/Ns     ⍝ values of named arrays (vars)
              kd←{0=≡⍵:⍵ ⋄ 3+4≡⊃⍵}        ⍝ kind from kind-tree
              Ds←v@{(kd¨Ks)∊2 9}⊢ds       ⍝ all definitions
              ↓⍉↑Ns Ks Ds                 ⍝ names kind-trees defns
          }                               ⍝ :: [N K D] ← ∇ S
     
          prep←{                          ⍝ preparation of ⎕cr forms
              (⊂⍺)∊0 2 9:⍵                ⍝ array operand: ignore
              1 1≡(≡⍵),⍴⍵:⊃⍵              ⍝ named primitive fn: disclose of 1-vector
              0∊⍴⍵:⍵                      ⍝ locked: ignore
              ⍺{                          ⍝ search of derv tree:
                  (2≡⍺)∨0=≡⍵:⍵            ⍝ array or atom: done
                  0≠≡⍺:⍺ ∇¨⍵              ⍝ nested: traverse
                  1<≢↓⍵:↑(⊂⍺ ∇⊃↓⍵),1↓↓⍵   ⍝ multi-line fn: without 'name←'
                  named←'←{'⍷⍵            ⍝ named dfn←{... ?
                  ~∨/named:⍵              ⍝ nope: ignore
                  1↓,(,∨\named)/⍵         ⍝ without 'name←'
              }⍵                          ⍝ for definition ⍵
          }                               ⍝ :: D ← K ∇ D
     
          derived←{0 1 0≡⍵∊4}             ⍝ is derived?: lft dop rgt
          sepr←{l d r←⍵ ⋄ l(d r)}         ⍝ separation: lft dop rgt → lft(dop rgt)
          curry←derived currying sepr     ⍝ currying of dyadic derived fns
     
          curry¨defs ⍵                    ⍝ (name kinds defn)-tuples
     
    ⍝   :: [N K D] ← ∇ space        ⍝ Name Kind Defn
    ⍝ N := ⍞                        ⍝   Name: char vector
    ⍝ K := 2 | 3 | 4 | 9 | [K]      ⍝   Kind-tree: nested kinds
    ⍝ D := ' | [D]                  ⍝   Defn: nested ⎕CR vectors
      }

      currying←{N K D←⍵               ⍝ adjustments for right-operand currying
          (⊂N),K ⍺⍺{                  ⍝ lft dop rgt ←→ lft(dop rgt)
              0=≡⍺:⍺ ⍵                ⍝ simple type: done
              adj←⍵⍵⍣(⍺⍺ ⍺)           ⍝ adjust if necessary
              ↓⍉↑(adj ⍺)∇¨adj ⍵       ⍝ for each component
          }⍵⍵ D                       ⍝ kind and defn trees
      }

      expr←{                                  ⍝ Linear representation of expression ⍵.
     
          ⍺←1 0 ⋄ N P←⍺,(≢⍺)↓0 0              ⍝ N:names P:parenthesised
     
          xpr←{K←|⊃k D←⍵                      ⍝ expression from nested defns
              cfmt←⎕SE.Dyalog.Utils.repObj    ⍝ char format
              (⊂K)∊2 9:⍺ cfmt⍣(k>0)⊢D         ⍝ array component
              0=≡K:⍕,D                        ⍝ single item: format
              pp←{∊⍺ 1 ⍺/'('⍵')'}             ⍝ parenthesised if ⍺
              pps←{(≢⍵)↑(4≡⊃⍵)↓P 0 1}         ⍝ left/right operand parentheses
              4∊K:⍺ pp⊃join/((pps K)∇¨↓⍉↑⍵),']'/⍨'['=2⊃D  ⍝ operator-derived expr:
              exp←~4∊¨K                       ⍝ train-tines requiring parens
              pns←(0≠≡¨¯1↓K),0                ⍝ leading non-simple tines
              ⍺ pp⊃join/(P∨pns∧exp)∇¨↓⍉↑⍵     ⍝ joined with parentheses ⍺
          }                                   ⍝ :: ⍞ ← ? ∇ K D
     
          join←({(0≤⎕NC⍪⍵)/⍵}⎕AV~'⍺⍵∇'){      ⍝ join of expressions
              adj←(⊢/⊣),(⊣/⊢)                 ⍝ adjoining: last of ⍺, first of ⍵
              gap←∧/(⍺ adj ⍵)∊⍺⍺,'¯',⎕D       ⍝ gap required between words ⍺ ⍵
              ∊1 gap 1/⍺' '⍵                  ⍝ separated sections
          }                                   ⍝ :: expr ← expr ∇ expr
     
          name←{(↓⌽↑⌽¨⍺),¨(⊂' ← '),¨⍵}⍣N      ⍝ with "name ← ..."
     
          ↑(⊃¨⍵)name 0 xpr¨¯2↑¨⍵              ⍝ formatted definitions
      }

      externs←{                               ⍝ External names referenced by fn ⍵.
     
          exts←{                              ⍝ external references
              1≠≡⍵:⍺ ∇ foldl ⍵,⊂,'⋄'          ⍝ inner fn: traverse
              X L P←⍺                         ⍝ Externals Locals Pending
              (⊂⍵)∊L:⍺                        ⍝ already local: no change
              0≤⎕NC ⍵~'⍺∇⍵':X L(P∪⊂⍵)         ⍝ name: pending
              ⍵≡,'←':X(L∪P)⍬                  ⍝ assignment: pending → local
              ~(⊃⍵)∊'⋄:':⍺                    ⍝ more in segment: continue
              (X∪P)L ⍬                        ⍝ end-of-segment: pending → external
          }                                   ⍝ :: [envt] ← [envt] ∇ func
     
          nest←{                              ⍝ nested tokens for nested functions
              ⍺←+\1 ¯1 0[(,¨'{}')⍳⍵]          ⍝ {}-nesting depths
              outer←⊃,(⊃⌽)                    ⍝ outermost tokens
              inner←{(1↓¯1↓⍺)⍺⍺ 1↓¯1↓⍵}       ⍝ ⍺⍺ applied between outer {}s
              '{}'≡∊outer ⍵:⊂(⍺-1)∇ inner ⍵   ⍝ recursive nesting of function body
              0∧.=⍺:⍵                         ⍝ no inner fns: done
              lft←(⍵∊⊂,'{')∧⍺=1               ⍝ top-level left braces
              rgt←0,¯1↓(⍵∊⊂,'}')∧⍺=0          ⍝ tokens following top-lvl right braces
              cut←1++\lft∨rgt                 ⍝ chopping at inner {} sections
              ⊃,/(cut⊆⍺)∇¨sort cut⊆⍵          ⍝ diamond and guard segs
          }                                   ⍝ :: func ← ∇ [tokn]
     
          sort←{                              ⍝ inner functions deferred until last
              ord←⍋⊃¨⍺                        ⍝ depth-of-segment order
              deps←(⊂ord)⌷⍺                   ⍝ depths
              segs←(⊂ord)⌷⍵                   ⍝ code segments
              deps ⍺⍺ segs                    ⍝ nesting per segment
          }                                   ⍝ :: func ← [[deps]] ∇ [[toks]]
     
          clean←{                             ⍝ de-fluffing of tokens vectors
              join←{¯1↓⊃,/⍵,¨⊂⊂,'⋄'}          ⍝ diamonds for newlines
              rmcm←{('⍝'≠⊃¨⍵)/⍵}              ⍝ without comments
              rmps←~∘(,¨'()')                 ⍝ without parens: '(a b)←' → 'a b←'
              ''glue foldl rmps rmcm join ⍵   ⍝ clean token vector
          }                                   ⍝ :: [tokn] ← ∇ [[tokn]]
     
          glue←{                              ⍝ gluing of compound name tokens a.b.c
              '.'≠⊃⊃⌽⍺:⍺,⊂⍵                   ⍝ not a '.' token: continue
              ~(⊃⍵)∊alph:⍺,⊂⍵                 ⍝ not a dotted name: continue
              (¯2↓⍺),⊂∊(¯2↑⍺),⍵               ⍝ dotted name: 'a.' 'b' → 'a.b'
          }                                   ⍝ :: [tokn] ← [tokn] ∇ tokn
     
          foldl←{⊃⍺⍺⍨/(⌽⍵),⊂⍺}                ⍝ fold left
     
          alph←{(0≤⎕NC⍪⍵)/⍵}⎕AV~'⍺⍵∇'         ⍝ start-of-name chars
     
          envt←⍬ ⍬ ⍬                          ⍝ Externs Locals Pending
          ⍺←0 ⋄ toks←60⌶,¨,⊆⎕NR⍣(~⍺)⊢⍵,⍺↑'⋄'  ⍝ unofficial: tokens from nested rep'n of function
          ⊃envt exts foldl nest clean toks    ⍝ external names
     
    ⍝ 0 externs :: [name] ← ∇ name      ⍝ names referenced by dfn ⍵
    ⍝ 1 externs :: [name] ← ∇ func      ⍝ names referenced by ⎕CR form ⍵
    ⍝      func := [tokn] | [func]      ⍝ function body: nested tokens vectors
    ⍝      tokn := ⍞                    ⍝ token, eg '⍺⍺' '⎕CR' '+'
    ⍝      envt := [name] [name] [name] ⍝ (externs locals pending)-triple
    ⍝      name := ⍞                    ⍝ name, eg 'test'
      }
    :EndSection
    :Section Text
    ∇ bcut←la psmum lengths;in;ispacing;iwidth;ittl;cut;n
    ⍝ Find Partition so +/⌈/¨ is under max
      (ispacing ittl)←+\⌽2↑la,1 ⋄ n←in←⍴lengths ⋄ cut←in↑1
      :Repeat ⋄ :Until ∧/bcut←cut
      n←n-1 ⋄ cut←in⍴n↑1
      :OrIf ittl≤+/ispacing+⌈/¨cut⊂lengths
    ∇

      showCol←{ ⍝ Show table in column format
        ⍝ Each row represents a word
          max←⌈/w←⍬∘⍴∘⍴¨words←trimEnds¨↓⍣(326≠⎕DR ⍵)⊢⍵
          0∊⍴words:0 0⍴''
          ⎕ML←⎕IO←1
        ⍝ We can specify the total width and minimum space between each word (column)
        ⍝ If the minimum is negative, the columns may not be of the same width
          ⍺←⍬ ⋄ la←{0∊⍴⍵:0 ' ' ⋄ ∨/0 2∊10|⎕DR ⍵:0 ⍵ ⋄ 2↑⍵}⍺
          la[2]←{3=10|⎕DR ⍵:⍵ ⋄ ⍴,⍵}spacer←2⊃la
          (spacing width)←{⍵[⍋⍵]}a,(⍳max∧.<a),(max∨.<a←la~0)↓⎕PW
          0>spacing:0 s↓⊃,/' ',⍣s¨⊢n↑¨↑¨c⊂words⊣n←1⍳⍨1⌽c←⎕PW s psmum w⊣s←-spacing
          w+←spacing
          nw←npl×nrw←⌈(⍴w)÷npl←⌊(width+spacing)÷max+spacing
          words←⍉(npl,nrw)⍴nw↑(max↑¨words),¨⊂spacing{3=10|⎕DR ⍵:⍺⍴'' ⋄ ⍵}spacer
          (0,-spacing)↓↑,/words
      }

⍝ Ex: 60  showCol ⎕nl 3 ⍝ 60 wide display of fns, 1 space between columns
⍝      3  showCol ⎕nl 3 ⍝ ⎕PW wide display of fns, 3 spaces in between cols
⍝ 78 '; ' showcol ⎕nl 2 ⍝ 78 wide display, '; ' between columns
⍝ ' | '   showCol ⎕nl 9 ⍝ ⎕PW wide, ' | ' between columns

    ∇ r←{options}showRow words;text;sh;blk;sp;pw;⎕ML;⎕IO;n    ⍝ fit a list ⎕PW wide
      ⍎(0=⎕NC'options')/'options←⍬' ⋄ ⎕ML←⎕IO←1
     ⍝ options are Printing Width, Granularity, min Spacing between words
      (pw blk sp)←options,(⍴,options)↓⎕PW,4 1 ⋄ pw←pw-sp
      sh←⊃,/⍴¨,¨text←{~∘' '¨↓⍵}⍣(326≠⎕DR words)+words ⍝ accept matrix of words
      sh←⊃,/⍴¨text←(blk×⌈blk÷⍨sh+sp)↑¨text ⍝ adjust each word's size
      r←0⍴⊂''
      :While 0<⍴text
          r←r,,/(n←1⌈+/pw≥+\sh)↑text ⋄ (text sh)←n↓¨text sh
      :EndWhile
      r←↑r
    ∇

    toMatrix←{⍺←3↓4↑⎕av ⋄ ⎕ml←0 ⋄ (2↑0∊⍴⍵)↓↑1↓¨(s∊⍺)⊂s←(1↑⍺),⍵} ⍝ multiple cut chars allowed

    toVector←{⍺←3↓4↑⎕av ⋄ b←,1,⌽∨\' '≠⌽⍵ ⋄ 1↓b/,⍺,⍵}

    trimEnds←{((∨\b)∧⌽∨\⌽b←' '≠⍵)/⍵}

    ∇ r←repObjQA;exprs;expr;⎕FR;fr;val;rep;Match;⎕IO
      exprs←r←⍬
⍝ Critical cases to handle:
      exprs,←⊂'(⍳100)÷10'
      exprs,←⊂'(⍳100)÷3'
      exprs,←⊂'(⍳10)×1j2'
      exprs,←⊂'(,1j2)(,1e1000)'
      exprs,←⊂'1J2 (,1E1000)'
      exprs,←⊂'(⍳100)×2*¯100'
      exprs,←⊂'1j1×(⍳100)×2*¯100'
      exprs,←⊂'1E1000 2E1000 3E1000 4E1000 5E1000 6E1000 7E1000 8E1000 9E1000 1E1001'
⍝ Real world data:
      exprs,←⊂'0.0007125 0.000735 0.0007575 0.00078 0.0008025 0.000825 0.0008475 0.0008625'
      exprs,←⊂'0.0007125 0.0007125 0.000735 0.0007575 0.00078 0.0008025 0.000825 0.0008475 0.0008625'
      exprs,←⊂'0.0007125 0.0007125 0.0007125 0.000735 0.0007575 0.00078 0.0008025 0.000825 0.0008475 0.0008625'
     
      Match←{⎕FR←⊃1287 645⌽⍨1289=⎕DR ⍺ ⋄ 0::0 ⋄ ⍺≡⍵}
      :For ⎕IO :In 0 1
          :For ⎕FR :In 645 1287
              :For expr :In exprs
                  val←⍎expr
                  rep←repObj val
                  :If ~r,←val Match⍎rep
                      'FAIL:(⎕IO ⎕FR)←',(⍕⎕IO ⎕FR),' ⋄ ⎕SE.Dyalog.Utils.repObj ',expr
                  :EndIf
              :EndFor
          :EndFor
      :EndFor
      r←∧/r
    ∇

      repObj←{ ⍝ String representation of object V0.35
      ⍝ Optional left arg: parenthesise if needed to isolate expression in context
     
          ⍺←0 ⍝ parenthesise if expression
          P←'(',')',⍨⍕
          10::P⍣⍺⊢'0(220⌶)0(219⌶)',∊P¨2 9(219⌶)1(220⌶)⍵
          ⎕FR←645 1287[⎕IO+1287=⎕DR ⍵] ⍝ prepare for decfs
          expr←{
              s←⍵/⍨~≠\''''=⍵ ⍝ remove strings
              p←s/⍨0=+\-⌿'()'∘.=s ⍝ remove parens
              b←p/⍨0=+\-⌿'[]'∘.=p ⍝ remove brackets
              ∨/'⊂,⍴+-×/⍳'∊p:P ⍵ ⍝ if expression; parenthesise
              ⍵
          }⍣⍺{
⍝ This version accounts for ⎕TC type characters
         ⍝ Recognise some constants:
              ⍵≡⍬:'⍬' ⋄ ⍵≡'':'''''' ⋄ ⍵≡⎕NULL:'⎕NULL'
              ⍵≡⎕D:'⎕D' ⋄ ⍵≡⎕A:'⎕A' ⋄ ⍵≡⎕Á:'⎕Á' ⋄ ⍵≡⎕AV:'⎕AV'
              scal←0∊rank←+/⍴s←⍴⍵ ⋄ char←>/(simple num)←∧\~(10|⎕DR 1/⍵)∊¨6(0 2)
         ⍝ Refs should normally not be displayed. To allow remove set ⍺[2] to 1
              ⍺←0              ⍝ recursive call?
              (rc ref)←2↑⍺
              or←scal∧1=≡R←⍵   ⍝ normally no funny objects like ⎕ORs
              or∨9=⎕NC'R':ref{~⍺:⎕SIGNAL⊂('EN' 11)('Message' 'Cannot represent refs') ⋄ ⍵}⍕⍵     ⍝ display refs as they are
     
⍝ Reduce object to 1 item if all same elements
              mod←(0<rank)∧(n=0)∨(5×char)<n←×/s
              mod←mod∧as←char{0∊⍴⍵:1 ⋄ 11::0 ⋄ ⍵∧.≡1↑⍵}obj←,⍵ ⍝ as: all the same (Mantis 18499)
              obj←mod{16::⊂'[ref]' ⋄ 1(↑⍣⍺)⍵}obj  ⍝ take only 1st? (grab prototype if empty)
              shape←mod{⍵≡,1:',' ⋄ (⍺∨1<⍴⍵)/'⍴',⍨⍕⍵}s
              shape←shape,(encl←simple<as)⍴'⊂'
     
⍝ Simple scalars and char vector≠⍴1 do not need parens
              parens←rc∧simple≤(0<⍴shape)∨(rank=1)∧num∨{80 82 160 320∊⍨⎕DR ⍵:∨/0 8 10 13 133∊⎕UCS ⍵ ⋄ 0}⍵
              (lp rp)←parens⍴¨'()'
              Paren←{>/'⎕' 'ADÁN'∊¨⍨2↑⍵:P ⍵ ⋄ ⍵} ⍝ Parenthesise complex expressions
              ~simple:rp,⍨lp,shape,encl{⍺⍲'('=1↑⍵:⍵ ⋄ 1↓¯1↓⍵}1↓⊃,/' ',¨Paren¨1 ref∘∇¨obj
     
⍝ Simple objects (char should account for ⎕TC chars et al.)
              ⎕PP←34 ⍝ for numbers
     
              cmpv←{⎕DCT←⎕CT←⎕IO←0                    ⍝ compress numeric vector
                  ⎕FR←645 1287[1289≠⎕DR ⍵]       ⍝ outer array may have been nested
                  ∨/e←(0∊s),⍬≡s←⍴v←⍵:⍕e/'⍬',1↑v  ⍝ empty or scalar
                  ⍺←4 ⋄ ⍺≥s:⍕v↑⍨⍺⌊s              ⍝ min length to consider compressing
                  d←{⍵>¯1⌽1 1 0⍷⍵}{1,⍵,⍨1↑⍵}2≠/2-/v
             ⍝ We know we have at least ONE section to deal with
             ⍝ We split the list into sections that either have to be compressed or not
                  s←-+/lim←{(⍵>1⌽⍵)∨⍵>¯1↓0,⍵}d   ⍝ where each section starts
                  addp←(s↑1)<s≠¯1                ⍝ where to add parentheses
                  r←1↓⊃,/addp{d v←⍵ ⋄ ∧/d:',',⍕v ⍝ all different?
                      lp←'[('[⍺] ⋄ rp←⍺/')' ⋄ ap←{',',lp,⍵,rp}
                      0=∆←-⍨/2⍴v:ap(⍕⍴v),'/',⍕1⍴v ⍝ all the same
                      A←(nz←0≠t)/⍕t←1⍴v          ⍝ write A+B×⍳C
                      A,←nz/'+'
                      B←(t≠1)/(⍕t←∆),'×'
                      C←'⎕io-⍨⍳',⍕⍴v
                      (⍴d←⍕v)>⍴t←A,B,C:ap t
                      ',',d
                  }¨↓⍉↑lim∘⊂¨d v
             ⍝ There may be some superflous commas
                  b←(','=r)⍲(¯1⌽r=')')⍱1⌽r∊'[('
                  x←(b\b/r)~'['
                  brace←5≤10|⎕DR ⍵
                  (ob cb)←brace/¨'({⎕io←0⋄'(1⌽')⊣⎕fr←⍵}',⍕⎕FR) ⍝ dfn to set ⎕FR if float
                  ⍵≡⍎x:ob,'⎕io-⍨'⎕R''⍣brace⊢x,cb
                  fmt←⍕⍵
                  ⍵≡⍎fmt:ob,cb,⍨⍕⍵
                  ⎕SIGNAL⊂('EN' 16)('Message' 'Generated expression did not match argument')⍝ NONCE
              }
     
              obj←shape,num ⍺{1↑⍺:cmpv ⍵ ⋄ ⎕ML←1 ⋄ ⎕IO←0 ⋄ QU←{Q,((1+t=Q)/t←⍵),Q←''''}
          ⍝ We have to assume not all characters are available. Those should be:
                  Always←⎕A,⎕D,'abcdefghijklmnopqrstuvwxyz_.,:;%!"/=\-+''#$£¢^¿¡(){}[]§@`∣¶&'
                  Always,←'ÁÂÃÇÈÊËÌÍÎÏÐÒÓÔÕÙÚÛÝþãìðòõÀÄÅÆÉÑÖØÜßàáâäåæçèéêëíîïñùúûüóôöø'
                  Always,←'≤≥⌿⍀<>≠∨∧÷×?∊⍴~↑↓⍳○*⌈⌷¨⌊∇∆⍙⍨∘⊂⊃∩∪⊥⊤⌶|⍺⍵¯⍬⍱⍲⍒⍋⍉⌽⊖⍟⌹⍕⍎⍫⍪≡≢⍷⋄←→⍝⎕⍞⍣ '
                  u←80=⎕DR''
                  Always,←'⊢⊣',⎕UCS u/8838 9016 9018 9056 9060 9080 ⍝ ⊂_ ⎕= ⎕⋄ ⎕: ∘¨ ⍳_
                  Always,←⎕UCS 9061/⍨u∧18≤1 0⊃'.'⎕VFI 1⊃# ⎕WG'APLVersion' ⍝ ○¨
                  ∧/t←⍵∊Always:QU ⍵ ⍝ no special chars?
            ⍝ If only a few chars transform the whole string into ⎕AV
                  UCS←{1⌽')(⎕ucs ',⍕cmpv ⎕UCS ⍵}
            ⍝ More than a few; create a mixture of ⎕UCS and 'quotes'
                  minsize←3 ⍝ how much special chars to include between sections; that number is subjective
                  c∨←minsize>∊⍴¨c←ucs⊂⍨c←1,1↓ucs≠¯1⌽ucs←~t ⍝ consider small groups of ASCII as UCS
             ⍝ ∧/sc←∊c:ucs ⍵ ⍝ are the pieces small enough to be all in ⎕UCS?
                  (lp rp)←'()'/⍨¨(1↓⍺)∧1<+/c←1,1↓ucs≠¯1⌽ucs←∊c
                  rp,⍨lp,∊{⍺,',',⍵}/(c/ucs){⍺:UCS ⍵ ⋄ QU ⍵}¨c⊂⍵
              }obj
              lp,obj,rp
          }⍵
          ⎕CT←⎕DCT←0
          ⍵≡⍎expr:expr
          ⎕SIGNAL⊂('EN' 16)('Message' 'Generated expression did not match argument')⍝ NONCE
      }

    ∇ string←{sep}toXML value;tag;s;v;⎕PP;repChar;⎕ML;dr;⎕IO
⍝ Turns an APL object into an XML representation
⍝ Simple scalars are turned into CHAR, NUMBER or NULL
⍝ Vectors or rank>1 are turned into ARRAYs of numeric LIST or char STRING
⍝ Characters are translated to be acceptable by ⎕XML
      ⎕PP←17 ⋄ ⎕ML←1 ⋄ ⎕IO←0 ⋄ sep←{6::'' ⋄ ⍎⍵}'sep'
      tag←{'<',s,⍵,'</',s←⍺,'>'}
     ⍝ Some characters cannot go thru ⎕XML, this is normal. The valid ones are
     ⍝ #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
     ⍝ That is any Unicode character, excluding the control chars, FFFE, and FFFF.
      v←'<>&',⎕UCS s←⎕AVU∩⍣(82∊⎕DR'')⍳32 ⍝ this may vary in e.g. Unix Classic
      s←'&lt;' '&gt;' '&amp;','£%'∘,¨(⎕D,⎕A)[s],¨';'
      repChar←s∘(v∘⍳{~∨/b←(⍴⍺)>i←⍺⍺ v←,⍵:⍵ ⋄ (b/v)←⍺[b/i] ⋄ ∊v})
      :If 0∊⍴⍴value ⍝ scalar
          :If 0∊1↑0⍴value ⋄ string←'number'tag⍕value
          :ElseIf ' '∊1↑0⍴value ⋄ string←'char'tag repChar value
          :ElseIf ⎕NULL≡value ⋄ string←'<null/>'
          :ElseIf 1≥|≡value ⋄ 'no Refs allowed'⎕SIGNAL 11
          :Else ⍝ must be enclosed
              string←'enclosed'tag sep toXML↑value
          :EndIf
      :Else ⍝ not a scalar
          s←'shape'tag⍕⍴value
          :If 2|dr←10|⎕DR value ⋄ string←'list'tag⍕,value
          :ElseIf dr∊0 2 ⋄ string←'string'tag repChar,value
          :Else
              string←∊sep∘toXML¨{0∊⍴⍵:⍬⍴⍵ ⋄ ⍵}value
              :If (1≥×/⍴value)∧1≢≡value ⋄ string←'enclosed'tag string ⋄ :EndIf
          :EndIf
          string←sep,'array'tag s,string
      :EndIf
    ∇

    ∇ value←fromXML string;mat;shape;⎕ML;type;array;enc;E;n;s;b;c;i;cc;ss
⍝ Turns an XML string into an APL object
⍝ The string must have been produced by the <toXML> fn above.
      ⎕ML←1 ⋄ E←'enclosed' ⍝ for ⊂
     ⍝ Character strings are transformed into a more suitable format
      :Select type←2⊃,mat←'whitespace' 'preserve'⎕XML⍣(0 2∊⍨10|⎕DR string)+string
     
      :CaseList 'array'E
      ⍝ The array could be enclosed several times
          n←2+enc←+/∧\mat[;2]∊⊂E
          shape←2⊃⎕VFI 3⊃mat[n;]
          value←fromXML¨(mat[n;1]=n↓mat[;1])⊂[1]n 0↓mat
          value←⊂⍣enc⌷shape⍴↑⍣(1∊⍴value)⌷value
      :CaseList 'list' 'number'
          value←⍬∘⍴⍣(type≡'number')+2⊃⎕VFI 3⊃,mat
      :CaseList 'string' 'char'
          b←(⍴s)↑3↓';'=s←3⊃,mat
          :If ∨/ss←b∧'£%'⍷s ⋄ c←¯2⌽ss     ⍝ any special sequence?
          :AndIf ∨/cc←33>i←(32↑⎕D,⎕A)⍳c/s ⍝ any control character?
              (cc/(¯1⌽c)/s)←⎕UCS cc/i-1   ⍝ replace the ; by the control character
              s←(~≠\↑∨/2 ¯1⌽¨⊂c\cc)/s     ⍝ remove special sequence extra characters
          :EndIf
          value←⍬∘⍴⍣(type≡'char')+s  ⍝ ⎕R too slow
      :Case 'null'
          value←⎕NULL
      :EndSelect
    ∇

    ∇ r←la txtreplace string;⎕IO;N;from;to;Fl;Tl;Fp;i;b;ip;n
⍝ Text Pattern Replace
⍝ la is a 2 elements enclosed strings: what to look for, the replacement string.
⍝ Ex: 'abc' 'xxyyzz' will turn all non overlapping 'abc' substrings into 'xxyyzz'
      (Fl Tl)←⍴¨(from to)←,¨la ⋄ Fp←⍴⎕IO←0 ⋄ N←⍴b←from⍷string←,string
      ⎕SIGNAL Fl↓11
      :If 1∊Fl ⋄ Fp←b/⍳⍴b ⍝ simple case
      :Else
          :While N>i←b⍳1  ⍝ remove overlapping matches
              (Fl↑i↓b)←0 ⋄ Fp,←i
          :EndWhile
      :EndIf
⍝ Do it
      :If 0<ip←⍴Fp
          :If 0>n←Fl-Tl   ⍝ do we need to insert spaces?
              b[]←1 ⋄ b[Fp]←1-n ⋄ string←b/string
              Fp←Fp-n×⍳ip ⍝ adjust positions
          :EndIf
          string[,Fp∘.+⍳Tl]←(ip×Tl)⍴to ⍝ replace
          :If n>0         ⍝ remove excess
              b[(Fp+Fl-1)∘.-⍳n]←~b[]←1
              string←b/string
          :EndIf
      :EndIf
      r←string
    ∇

    ∇ txt←condRavel txt;crs;s;CR;LF;ncr
    ⍝ Conditionally ravel text where CR are followed by non-white Spaces
    ⍝ e.g. 'x',CR,'x' is changed by 'x x'
      (LF CR)←2↓4↑⎕AV
      :If 1<⍴⍴txt ⋄ txt←1↓,CR,txt ⋄ :EndIf
      txt[(txt=LF)/⍳⍴txt]←CR ⍝ LF=CR
    ⍝ We first remove the spaces at the end of each line
      ncr←CR≠1↑txt
      txt←{(⍵∊CR)⊂⍵}(ncr↑CR),txt ⍝ each line
      s←-⊥⍨¨' '=¨txt ⍝ number of spaces to drop at the end of each line
      txt←⊃,/s↓¨txt  ⍝ drop them, merge lines
      crs←s/⍳⍴s←0,1↓¯1↓CR=txt ⍝ find where the CRs are and replace by
      txt[(⍱⌿txt[¯1 1∘.+crs]∊CR,' ')/crs]←' ' ⍝ space those between words
      txt←ncr↓txt    ⍝ remove CR added
    ∇

    ∇ rfmtxt←{n}reshapeText text;⎕IO;b;d;line;n1;s;CR
    ⍝ Embed the CR character into the text so lines are
    ⍝ approximately and at most 'n' long. Existing CRs are left in.
    ⍝ If the text contains CRs to be removed use function <condRavel>.
      :If 0=⎕NC'n' ⋄ n←⎕PW ⋄ :Else ⋄ n⌈←2 ⋄ :EndIf
      ⎕IO←0 ⋄ rfmtxt←'' ⋄ text←,text ⋄ n1←1+n ⋄ CR←⎕AV[3]
      :While n<⍴text
          :If 0∊s←CR≠line←n1↑text            ⍝ any CR in line?
              rfmtxt←rfmtxt,(-d←s⊥s)↓line    ⍝ keep up to last CR
              text←(n1-d)↓text
          :ElseIf ¯1↑s←' '=line              ⍝ No CRs in line; does the line fit?
              rfmtxt←rfmtxt,((-s⊥s)↓line),CR ⍝ it does
              text←n1↓text
          :ElseIf ~∨/s                       ⍝ cut at last space. Any?
              rfmtxt←rfmtxt,(¯2↓line),'-',CR ⍝ no, add a dash too
              text←(n-1)↓text
          :Else ⍝ line contains spaces but the last word does not fit
              b←(b⍳1)↓b←⌽s ⋄ text←(⍴b)↓text  ⍝ forget last word
              d←(⍴b)-b⍳0                     ⍝ number of chars to take
              rfmtxt←rfmtxt,(d↑line),CR
          :EndIf
      :EndWhile
      rfmtxt←rfmtxt,text
    ∇

    ∇ text←{vals}formatText text;cr;pw;right;hang;first;lead;left
    ⍝ Format text according to specifications (see ]format -?)
      :If 900⌶⍬ ⋄ vals←0 ⋄ :EndIf
      text←{(+/∨\' '≠⌽⍵)↑¨↓⍵}∘⎕FMT⍣(1=≡text)⊢text ⍝ convert everything to VTV
      text←↑,/(⊂''),(⊂vals)formatPar¨text
    ∇

    ∇ text←{vals}formatPar text;cr;pw;right;hang;first;lead;left
    ⍝ Format paragraph according to specifications (see ]format -?)
      :If 900⌶⍬ ⋄ vals←0 ⋄ :EndIf
      (left right first)←{1≤|⍵:⍵ ⋄ ⌊0.5+⎕PW×⍵}¨3↑vals
      cr←⎕UCS 13
      pw←⎕PW-right
      hang←|0⌊first
      lead←hang↑text
      text←(-first+⍴text)↑text
      text←condRavel↑text
      text←(pw-left)reshapeText text
      text,⍨←cr
      text←(left⍴' ')∘,¨1↓¨(text=cr)⊂text
      (left↑⊃text)←(-left)↑lead
    ∇

    ∇ text←layoutText text;lead;left;cr;right
    ⍝ Layout text according to ]layout -? rules
      text←{(+/∨\' '≠⌽⍵)↑¨↓⍵}∘⎕FMT⍣(1=≡text)⊢text ⍝ convert everything to VTV
      text←↑,/(⊂''),layoutPar¨text
    ∇

    ∇ text←layoutPar text;lead;left;cr;right
    ⍝ Layout paragraph according to ]layout -? rules
      cr←⎕UCS 13
      right←+/∧\' '=⌽text
      text←(-right)↓text
      left←⌈/3↑¯1+(2≠/'  '⍷'  ',text)/⍳1+⍴text
      lead←left↑text
      text←left↓text
      text←(⎕PW-⌈left+right)reshapeText text
      text,⍨←cr
      text←(left⍴' ')∘,¨1↓¨(text=cr)⊂text
      (left↑⊃text)←lead
    ∇

    ∇ setupKeys arg;sp
    ⍝ arg is a char vector possibly embedded with or followed by an enclosed string, eg: 'dothis',⊂'ER'
      :If ''≡arg
          sp←{d←326=⎕DR ¯1↑v←,⍵ ⋄ v[b/⍳⍴b←'"'≡¨v]←'''' ⋄ ⍺,(v,d↓⊂'ER')⎕PFKEY ⍺}
         ⍝ e.g. 13 sp'"." ⎕wg "aplversion"'
          2 sp'⎕se.SALTUtils.EditorFix "chk"'
      :EndIf
    ∇
    :EndSection

    :Namespace qa
        ∇ ok←ExpandConfig;r
          r←'text','text',⍨∊4⍴⊂2 ⎕NQ #'GetEnvironment' 'DYALOG'
          ok←r≡##.ExpandConfig'text[DYALOG]$DYALOG$env:DYALOG%DYALOG%text'
          :If ~⎕SE.SALTUtils.WIN
              r←'/',⍨2 ⎕NQ #'GetEnvironment' 'HOME'
              ok,←##.ExpandConfig'~'
              r←'/',⍨2 ⎕NQ #'GetEnvironment' 'PWD'
              ok,←##.ExpandConfig'~+'
              r←'/',⍨2 ⎕NQ #'GetEnvironment' 'OLDPWD'
              ok,←##.ExpandConfig'~-'
          :EndIf
          ok←∧/ok
        ∇
    :enDNamespace
:EndNameSpace ⍝ Utils  $Revision: 1827 $
